# 2.1 网络编程基础

网络编程是构建现代互联网应用的基石，它使得分布式系统中的各个组件能够进行通信和协作。在互联网时代，几乎所有的应用程序都依赖于网络编程，从简单的网页浏览到复杂的在线多人游戏，无一例外。在本节中，我们将深入探讨网络编程的基本概念和应用，这包括网络编程的基础概念以及套接字编程实践，并会通过构建“拳皇”这一经典双人对战小游戏的实例，进一步深化网络编程的概念和实践。

### 2.1.1 网络编程的基础概念

网络编程是指在网络上的主机通过不同的进程，以编程的方式实现网络通信。即使是在同一台主机上的不同进程，只要是基于网络进行数据传输，也属于网络编程的范畴。**本质上，网络编程是学习如何利用传输层为应用层提供的API接口**。通过编写代码，我们可以将数据交给传输层处理，传输层会对数据进行层层封装，最终通过网卡将数据发送到网络中。这一过程使得不同设备或进程之间能够实现高效、可靠的通信。

通过深入理解和应用这些API，开发者可以构建出各种强大且灵活的网络应用，从简单的文件传输到复杂的在线游戏。在本章的基础实验中，我们将探讨在同一台主机上的不同进程如何通过网络编程进行通信。这些实验将涵盖从基础的网络通信到同步问题的解决，逐步引导读者掌握网络编程的核心技术，为进一步理解和应用打下坚实的基础。

### 2.1.2 基础的网络协议

计算机网络采用分层抽象的思维方式，将复杂的网络功能分解为多个独立的层次，以便更好地管理和优化各个部分的工作。常见的分层方法主要有两种：OSI七层模型和TCP/IP五层模型。在这两种模型中，每一层都负责特定的网络功能。

本文将以TCP/IP五层模型为基础，介绍每一层中的一些基础协议。TCP/IP五层模型的五个层次从下至上依次是物理层、数据链路层、网络层、传输层和应用层。每一层在网络通信过程中扮演着独特的角色，协同工作以实现高效、可靠的数据传输。

| 五层模型中的抽象层 | 主要功能                         | 协议                     |
| --------- | ---------------------------- | ---------------------- |
| 应用层       | 提供网络应用和服务的接口。                | HTTP、FTP、SSH           |
| 传输层       | 负责端到端的通信、流量控制、差错检测和纠正。       | TCP、UDP、SCTP           |
| 网络层       | 负责数据包在不同网络间的路由和转发。           | IP、ICMP、ARP、RARP       |
| 数据链路层     | 负责节点间的可靠数据传输、帧同步、流量控制、差错控制等。 | Ethernet、PPP、HDLC      |
| 物理层       | 负责在物理介质上传输比特流。               | IEEE 802.3、IEEE 802.11 |

分层结构的好处在于软件开发者可以专注于自己负责的那一层的业务逻辑，因为其他层会提供安全可靠的服务支持。这样，开发者无需了解所有层次的细节，可以更高效地开发和维护系统。一般来说，如果不是硬件工程师，开发者通常接触最多的是网络层及以上的抽象层。

在简单的云计算开放领域，TCP和UDP是使用最广泛的两种传输层协议。为了在实际应用中使用这些协议，离不开套接字编程。因此，下面将详细介绍TCP和UDP的应用范围以及它们的套接字编程方法。

#### 2.1.2.1 套接字

套接字（Socket）是计算机网络通信中的一种抽象概念，用于描述应用程序与网络之间的接口。它为应用程序提供了一种机制，使其能够在网络上发送和接收数据，从而实现分布式通信。套接字通常用于实现客户端和服务器之间的通信。套接字可以看作是应用程序通过网络进行数据传输的端点。每个套接字在网络上都有一个独特的组合标识，即IP地址和端口号。套接字通信可以基于不同的协议，如TCP和UDP。

根据协议的不同，套接字可以分为TCP套接字与UDP套接字两种。

1. TCP套接字
   * **特点**：面向连接、可靠传输、数据流形式传输。
   * **应用**：网页浏览HTTP/HTTPS、文件传输FTP、电子邮件SMTP等可靠服务。
2. UDP套接字
   * **特点**：无连接、不可靠传输、数据包形式传输。
   * **应用**：用于需要快速传输并且可以容忍一定数据丢失的应用，如实时媒体会议、网络游戏等。

不管协议如何，套接字编程所需要的步骤都是类似的，这也是分层好处的又一体现，即我们只需要调用api来帮助我们做一些事情即可。下面介绍这两类协议的套接字编程。

#### 2.1.2.2 TCP套接字编程

1. **创建套接字**：调用`socket()`函数，指定地址族（如IPv4）和套接字类型（如流套接字）。
2. **绑定地址**（服务器端）：使用`bind()`函数将套接字绑定到指定的IP地址和端口。
3. **监听连接**（服务器端）：调用`listen()`函数，使套接字进入监听状态，准备接受连接请求。
4. **接受连接**（服务器端）：使用`accept()`函数接受客户端的连接请求，返回一个新的套接字用于通信。
5. **连接服务器**（客户端）：调用`connect()`函数连接到服务器的IP地址和端口。
6. **发送和接收数据**：使用`send()`和`recv()`函数在客户端和服务器之间传输数据。
7. **关闭连接**：调用`close()`函数关闭套接字，终止通信。

以TCP的服务器为例，我们可以简短地写一段编程代码：

```cpp
#include <iostream>
#include <cstring>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};

    // 创建套接字
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置端口复用
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(12345);

    // 绑定地址
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // 监听连接
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    std::cout << "服务器正在监听..." << std::endl;

    // 接受客户端连接
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept");
        exit(EXIT_FAILURE);
    }

    // 接收数据
    read(new_socket, buffer, 1024);
    std::cout << "收到数据: " << buffer << std::endl;

    // 发送数据
    const char *hello = "Hello, Client!";
    send(new_socket, hello, strlen(hello), 0);
    std::cout << "Hello消息已发送" << std::endl;

    // 关闭套接字
    close(new_socket);
    close(server_fd);

    return 0;
}

```

#### 2.1.2.3 UDP编程

1. **创建套接字**：调用`socket()`函数，指定地址族和套接字类型（如数据报套接字）。
2. **绑定地址**（服务器端）：使用`bind()`函数将套接字绑定到指定的IP地址和端口。
3. **发送数据**：调用`sendto()`函数将数据发送到指定的IP地址和端口。
4. **接收数据**：使用`recvfrom()`函数从指定的IP地址和端口接收数据。
5. **关闭套接字**：调用`close()`函数关闭套接字。

```cpp
#include <iostream>
#include <cstring>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main() {
    int sockfd;
    struct sockaddr_in servaddr, cliaddr;
    char buffer[1024];
    socklen_t len;
    ssize_t n;

    // 创建套接字
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // 填写服务器信息
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(12345);

    // 绑定地址
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
        perror("bind failed");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    std::cout << "服务器正在监听..." << std::endl;

    len = sizeof(cliaddr);

    // 接收数据
    n = recvfrom(sockfd, (char *)buffer, 1024, MSG_WAITALL, (struct sockaddr *)&cliaddr, &len);
    buffer[n] = '\0';
    std::cout << "收到来自客户端的数据: " << buffer << std::endl;

    // 发送数据
    const char *hello = "Hello, Client!";
    sendto(sockfd, hello, strlen(hello), MSG_CONFIRM, (const struct sockaddr *)&cliaddr, len);
    std::cout << "Hello消息已发送" << std::endl;

    // 关闭套接字
    close(sockfd);

    return 0;
}

```

可以发现，UDP套接字编程比TCP的套接字编程会少几个步骤，这是因为UDP不需要建立连接与绑定IP，只需要接受数据包即可，后续的“拳皇游戏”也将会使用UDP编程。
